Pointer Concepts – Assignment Notes

1. Normal Variable vs Pointer
A normal variable stores a value directly, for example int x = 5.
A pointer stores the address of another variable, for example int *p = &x.

- Normal variable → value is accessed directly.
- Pointer → value is accessed indirectly using *.
- Changing values: x = 10; changes the variable directly, while *p = 10; changes the value of x through the pointer.


2. Variable vs Pointer Declaration
Declaring a variable means reserving space for a value, e.g. int a;
Declaring a pointer means reserving space for an address, e.g. int *p;

- & is used to get the address of a variable.
- * is used to access the value at that address.

Example:
int a = 5;
int *p = &a;


3. Dereferencing a Pointer
Dereferencing means using * to get or change the value stored at the address a pointer holds.

Example:
int a = 10;
int *p = &a;
printf("%d", *p); // prints 10
*p = 20;          // changes a to 20


4. When Pointers Are Preferred
Pointers are useful when:
- Allocating memory at runtime (malloc).
- Passing variables to functions so they can be modified.
- Building data structures like linked lists.

Examples:
- Swapping two values using pointers.
- Traversing an array with pointer arithmetic.


5. Limitations and Risks
- Dangling pointers (pointing to freed memory).
- Memory leaks (forgetting to free memory).
- Segmentation faults (invalid memory access).
- Code can be harder to debug.


6. Call by Value vs Call by Reference
- Call by value: a copy of the variable is passed, so the original does not change.
- Call by reference: the address is passed, so the original can be changed.

Example:
void changeValue(int x) { x = 10; }
void changeReference(int *x) { *x = 10; }


7. Practical Scenarios
- Call by value: preferred when the original data should not be changed, or for small data types.
- Call by reference: preferred when the function needs to update the original variable, or when working with large structures to avoid copying.
